use std::{fs, io::BufReader, path::Path};

use approx::assert_abs_diff_eq;
use ndarray::Array2;

#[derive(Debug, Clone)]
pub struct TestData {
    input: Array2<f64>,
    output: Array2<f64>,
}

impl TestData {
    pub fn new(dim: usize, input_vec: Vec<f64>, output_vec: Vec<f64>) -> Self {
        unsafe {
            Self {
                input: Array2::from_shape_vec_unchecked((dim, dim), input_vec),
                output: Array2::from_shape_vec_unchecked((dim, dim), output_vec),
            }
        }
    }

    pub fn get_data(&self) -> (Array2<f64>, Array2<f64>) {
        (self.input.to_owned(), self.output.to_owned())
    }

    pub fn test<F: Fn(Array2<f64>) -> Array2<f64>>(&self, f: F) {
        assert_abs_diff_eq!(f(self.input.to_owned()).to_owned(), self.output)
    }
}

/// read test data followed by below format: 
/// \# is comment
/// ```text
/// # generated by python...
/// 2
/// 3
/// i i i
/// i i i
/// i i i
/// o o o
/// o o o
/// o o o
/// 2
/// i i 
/// i i
/// o o
/// o o
/// ```
pub fn read_test_data<P: AsRef<Path>>(p: P) -> Vec<TestData> {
    let mut v: Vec<TestData> = Vec::new();

    #[allow(unused_mut)]
    let mut r = BufReader::new(fs::File::open(p).unwrap());
    let mut reader = Reader::new(r);

    let n: usize = reader.read();

    for _ in 0..n {
        let dim: usize = reader.read();
        let input_vec: Vec<f64> = reader.vec(dim * dim);
        let output_vec: Vec<f64> = reader.vec(dim * dim);
        v.push(
            TestData::new(dim, input_vec, output_vec)
        )
    }

    v
}


pub struct Reader<R>(R);

impl<R: std::io::Read> Reader<R> {
    pub fn new(r: R) -> Self {
        Reader(r)
    }
    pub fn read<T: std::str::FromStr>(&mut self) -> T {
        use std::io::Read;

        #[allow(unused_assignments)]
        let mut ret = "".to_string();

        loop {
            let buf = self
                .0
                .by_ref()
                .bytes()
                .map(|b| b.unwrap())
                .skip_while(|&b| b == b' ' || b == b'\n' || b == b'\r' || b == b'\t')
                .take_while(|&b| b != b' ' && b != b'\n' && b != b'\r' && b != b'\t')
                .collect::<Vec<_>>();
            let s = unsafe { std::str::from_utf8_unchecked(&buf).to_owned() };
            if !s.starts_with("#") {
                ret = s;
                break;
            }
        }

        ret.parse()
            .ok()
            .expect("Parse error.")
    }
    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {
        (0..n).map(|_| self.read()).collect()
    }
}

